(window.webpackJsonp=window.webpackJsonp||[]).push([[252],{606:function(v,_,p){"use strict";p.r(_);var n=p(8),t=Object(n.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("第一章：当我们在讨论算法的时候，我们在讨论什么？")]),v._v(" "),_("p",[v._v("​    1-1 我们究竟为什么要学习算法")]),v._v(" "),_("p",[v._v("​    1-2 课程介绍")]),v._v(" "),_("p",[v._v("第二章：排序基础")]),v._v(" "),_("p",[v._v("​    2-1 选择排序法")]),v._v(" "),_("p",[v._v("2-2 使用模板（泛型）编写算法")]),v._v(" "),_("p",[v._v("2-3 随机生成算法测试用例")]),v._v(" "),_("p",[v._v("​    2-4 测试算法的性能")]),v._v(" "),_("p",[v._v("​    2-5 插入排序法")]),v._v(" "),_("p",[v._v("​    2-6 插入排序法的改进")]),v._v(" "),_("p",[v._v("​    2-7 更多关于O（n*2）排序算法的思考")]),v._v(" "),_("p",[v._v("第三章：高级排序问题")]),v._v(" "),_("p",[v._v("​    3-1 归并排序法")]),v._v(" "),_("p",[v._v("​    3-2 归并排序法的实现")]),v._v(" "),_("p",[v._v("​    3-3 归并排序法的优化")]),v._v(" "),_("p",[v._v("​    3-4 自底向上的归并排序算法")]),v._v(" "),_("p",[v._v("​    3-5 快速排序法")]),v._v(" "),_("p",[v._v("​    3-6 随机化快速排序法")]),v._v(" "),_("p",[v._v("​    3-7 双路快速排序法")]),v._v(" "),_("p",[v._v("​    3-8 三路快速排序法")]),v._v(" "),_("p",[v._v("​    3-9 归并排序和快速排序的衍生问题")]),v._v(" "),_("p",[v._v("第四章：堆和堆排序")]),v._v(" "),_("p",[v._v("​    4-1 为什么使用堆")]),v._v(" "),_("p",[v._v("​    4-2 堆的基本存储")]),v._v(" "),_("p",[v._v("​    4-3 Shift Up")]),v._v(" "),_("p",[v._v("​    4-4 Shift Down")]),v._v(" "),_("p",[v._v("​    4-5 基础堆排序和Heapify")]),v._v(" "),_("p",[v._v("​    4-6 优化的堆排序")]),v._v(" "),_("p",[v._v("​    4-7 排序算法总结")]),v._v(" "),_("p",[v._v("​    4-8 索引")]),v._v(" "),_("p",[v._v("4-9 索引堆的优化")]),v._v(" "),_("p",[v._v("4-10 和堆相关的其他问题")]),v._v(" "),_("p",[v._v("第五章：二分搜索树")]),v._v(" "),_("p",[v._v("​    5-1 二分查找法")]),v._v(" "),_("p",[v._v("​    5-2 二分搜索树基础")]),v._v(" "),_("p",[v._v("​    5-3 二分搜索树的节点插入")]),v._v(" "),_("p",[v._v("​    5-4 二分搜索书的查找")]),v._v(" "),_("p",[v._v("​    5-5 二分搜索树的遍历（深度优先遍历）")]),v._v(" "),_("p",[v._v("​    5-6 层序遍历（广度优先遍历）")]),v._v(" "),_("p",[v._v("​    5-7 删除最大值，最小值")]),v._v(" "),_("p",[v._v("​    5-8 二分搜索树的删除")]),v._v(" "),_("p",[v._v("​    5-9 二分搜索树的顺序性")]),v._v(" "),_("p",[v._v("​    5-10 二分搜索树的局限性")]),v._v(" "),_("p",[v._v("​    5-11 树形问题和更多树。")]),v._v(" "),_("p",[v._v("第六章:并查集")]),v._v(" "),_("p",[v._v("​    6-1 并查集基础")]),v._v(" "),_("p",[v._v("​    6-2 Qucik Find")]),v._v(" "),_("p",[v._v("​    6-3 Quick Union")]),v._v(" "),_("p",[v._v("​    6-4 基于size的优化")]),v._v(" "),_("p",[v._v("​    6-5 基于rank的优化")]),v._v(" "),_("p",[v._v("6-6 路径压缩")]),v._v(" "),_("p",[v._v("第七章:")]),v._v(" "),_("p",[v._v("​    7-1 图论基础")]),v._v(" "),_("p",[v._v("​    7-2 图的表示")]),v._v(" "),_("p",[v._v("​    7-3 相邻点迭代器")]),v._v(" "),_("p",[v._v("​    7-4 图的算法框架")]),v._v(" "),_("p",[v._v("​    7-5 深度优先遍历和联通分量")]),v._v(" "),_("p",[v._v("​    7-6 寻路")]),v._v(" "),_("p",[v._v("​    7-7 广度优先遍历和最短路径")]),v._v(" "),_("p",[v._v("​    7-8 迷宫生成，ps抠图--更多无权图的应用")]),v._v(" "),_("p",[v._v("第八章：最小生成树")]),v._v(" "),_("p",[v._v("​    8-1 有权图")]),v._v(" "),_("p",[v._v("​    8-2 最小生成树问题和切分定理")]),v._v(" "),_("p",[v._v("​    8-3 Prim算法的第一个实现")]),v._v(" "),_("p",[v._v("​    8-4 Prim算法的优化")]),v._v(" "),_("p",[v._v("​    8-5 优化后的Prim算法的实现")]),v._v(" "),_("p",[v._v("​    8-6 Krusk算法")]),v._v(" "),_("p",[v._v("​    8-7 最小生成树算法的思考")]),v._v(" "),_("p",[v._v("第九章：最短路径")]),v._v(" "),_("p",[v._v("9-1 最短路径问题和松弛操作")]),v._v(" "),_("p",[v._v("​    9-2 Dijkstra算法的思想")]),v._v(" "),_("p",[v._v("​    9-3 实现Dijkstra算法")]),v._v(" "),_("p",[v._v("​    9-4 负权边和Bellman-Ford算法")]),v._v(" "),_("p",[v._v("​    9-5 实现Bellman-Ford算法")]),v._v(" "),_("p",[v._v("9-6 更多和最短路径相关的思考")]),v._v(" "),_("p",[v._v("第十章：结束语")]),v._v(" "),_("p",[v._v("10-1 总结，算法思想")])])}),[],!1,null,null,null);_.default=t.exports}}]);