(window.webpackJsonp=window.webpackJsonp||[]).push([[83],{440:function(t,r,v){"use strict";v.r(r);var a=v(8),_=Object(a.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"服务限流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#服务限流"}},[t._v("#")]),t._v(" 服务限流")]),t._v(" "),r("h4",{attrs:{id:"什么是服务限流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是服务限流"}},[t._v("#")]),t._v(" 什么是服务限流")]),t._v(" "),r("p",[t._v("限流就是为了提供稳定的服务，限制使用人数。")]),t._v(" "),r("p",[t._v("限流的目的是通过对并发请求进行限速，或者对一个时间窗口内的请求数量进行限速来保护系统。")]),t._v(" "),r("p",[t._v("一旦达到限制速率可以拒绝服务、排队或者等待。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220412105549096.png",alt:"image-20220412105549096"}})]),t._v(" "),r("h4",{attrs:{id:"多维度进行限流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#多维度进行限流"}},[t._v("#")]),t._v(" 多维度进行限流")]),t._v(" "),r("p",[t._v("请求到达服务接口时，可以采用多维度限流策略。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220412110052030.png",alt:"image-20220412110052030"}})]),t._v(" "),r("h4",{attrs:{id:"限流算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#限流算法"}},[t._v("#")]),t._v(" 限流算法")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("限流算法-计数器（固定窗口）")]),t._v(" "),r("p",[t._v("计数器限制，每一分钟或者每一秒钟内的请求不能超过一定的次数，在下一秒计时器清零重新计算")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220412111040388.png",alt:"image-20220412111040388"}})]),t._v(" "),r("p",[r("strong",[t._v("存在的问题")]),t._v("：")]),t._v(" "),r("p",[t._v("客户端在第一分钟的59秒请求了100次，又在第二分钟的1秒请求了100次，2秒内，后端要承受200次请求的压力，形成了流量突刺")])]),t._v(" "),r("li",[r("p",[t._v("限流算法-计数器（滑动窗口）")]),t._v(" "),r("p",[t._v("滑动窗口是细分后的计数器。它将每个时间窗口又划分成若干个时间片段，每过一个时间片段，整个时间窗口就会向右移动一格。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220412112229172.png",alt:"image-20220412112229172"}})])])]),t._v(" "),r("p",[t._v("打满100次，客户端就拒绝访问。")]),t._v(" "),r("p",[t._v("时间窗口划分的越细，滑动窗口的滚动越平滑，限流效果越精确。")]),t._v(" "),r("ol",{attrs:{start:"3"}},[r("li",[r("p",[t._v("限流算法-漏桶")]),t._v(" "),r("p",[t._v("漏桶算法类似一个限制出水速度的水桶，通过一个固定大小的FIFO队列+定时取队列元素的方式实现。")]),t._v(" "),r("p",[t._v("请求进入队列后，会被匀速取出来处理，类似桶底部的开口匀速出水。当队列被占满后，后来的请求会直接被拒绝，类似水倒得太快溢出来。")]),t._v(" "),r("p",[t._v("优点是可以削峰填谷，不论请求多大多快，都只会匀速发给后端，不会出现突刺现象，保证下游服务正常运行。")]),t._v(" "),r("p",[t._v("缺点是桶队列中的请求会排队，响应时间拉长。")])]),t._v(" "),r("li",[r("p",[t._v("限流算法-令牌桶")]),t._v(" "),r("p",[t._v("令牌桶算法是以恒定的速度往桶里放置令牌，如果桶里的令牌满了就放弃，每进来一个请求去桶里找令牌，有的话拿走令牌继续处理，没有就拒绝请求。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220412132838290.png",alt:"image-20220412132838290"}})])])]),t._v(" "),r("p",[t._v("令牌桶的优点是可以应对突发流量，当桶里有令牌时可以快速响应也不会产生漏桶队列中的等待时间。")]),t._v(" "),r("p",[t._v("缺点是相对于漏桶，一定程度上减少了对下游服务的保护。")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.cnblogs.com/junzi2099/p/14208640.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/junzi2099/p/14208640.html"),r("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=_.exports}}]);