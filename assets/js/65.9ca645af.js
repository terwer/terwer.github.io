(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{422:function(t,a,r){"use strict";r.r(a);var e=r(8),s=Object(e.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"分布式理论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#分布式理论"}},[t._v("#")]),t._v(" 分布式理论")]),t._v(" "),a("h3",{attrs:{id:"数据一致性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据一致性"}},[t._v("#")]),t._v(" 数据一致性")]),t._v(" "),a("h4",{attrs:{id:"什么是分布式数据一致性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是分布式数据一致性"}},[t._v("#")]),t._v(" 什么是分布式数据一致性")]),t._v(" "),a("p",[t._v("分布性数一致性，指的是数据在多份副本中存储时，各副本中的数据是一致的。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220317203744981.png",alt:"image-20220317203744981"}})]),t._v(" "),a("h4",{attrs:{id:"副本一致性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#副本一致性"}},[t._v("#")]),t._v(" 副本一致性")]),t._v(" "),a("p",[t._v("分布式系统中，数据往往会有读个副本。多个副本就需要保证数据一致性。这就带来了同步的问题，因为网络阻塞等因素，我们几乎无法保证可以同时更新所有机器中的所有数据，就会有数据不一致。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220317204315708.png",alt:"image-20220317204315708"}})]),t._v(" "),a("p",[t._v("总之，无法找到满足分布式系统数据一致性的解决方案。因此，如何保证数据一致性，同时又不影响性能，是每一个分布式系统需要考虑和权衡的。所以，就产生了一致性级别。")]),t._v(" "),a("h4",{attrs:{id:"一致性分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一致性分类"}},[t._v("#")]),t._v(" 一致性分类")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("强一致性")]),t._v(" "),a("p",[t._v("符合用户直觉的。它要求用户写进去是什么，读出来就是什么。用户体验好，但是实现起来对性能影响较大。强一致性很难实现。")])]),t._v(" "),a("li",[a("p",[t._v("弱一致性")]),t._v(" "),a("p",[t._v("约束了系统在写入成功后，不承诺立即读到写入的值，也不承诺数据多久达成一致，但是会尽可能保证某个时间级别（比如秒级别）后，数据能达到一致。")])]),t._v(" "),a("li",[a("p",[t._v("最终一致性")]),t._v(" "),a("p",[a("strong",[t._v("最终一致性是弱一致性的一种")]),t._v("，无法保证数据更新后，后续所有访问都能获取到最新值，需要一个时间，在这个时间之后可以保证这一点（"),a("strong",[t._v("在一个时间节点之后，数据会最终达到一致")]),t._v("）。在这个时间之内，数据可能会不一致，这个系统无法保证强一致性的时间片段被称为不一致窗口。不一致时间窗口的时间长短取决于很多因素，比如备份数据的个数、网络传输延迟、系统负载等。")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220317210009123.png",alt:"image-20220317210009123"}}),t._v("\n最终一致性在实际应用中有很多变种")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("因果一致性")]),t._v(" "),a("p",[t._v("如果进程A通知进程B更新了一个数据项，那么进程B的后续访问将返回更新后的值。与进程A无因果关系的进程C的访问将遵守一般的最终一致性规则。")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220317215154546.png",alt:"image-20220317215154546"}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("读已之所写一致性")]),t._v(" "),a("p",[t._v("当进程A更新一个数据项之后，它总是访问到更新过的值，不会看到旧值。这是因果一致性的特例。")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220317222852440.png",alt:"image-20220317222852440"}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("会话一致性")]),t._v(" "),a("p",[t._v("把访问存储系统的进程放到会话的上下文。只要会话还在，就能保证”读己之所写一致性“。如果由于某些失败情形会话终止，就要建立新的会话，而且系统的保证不会延续到新的会话。")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220317223501094.png",alt:"image-20220317223501094"}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("单调读一致性")]),t._v(" "),a("p",[t._v("如果一个进程已经读取到一个特定值，那么该进程不会读取到该值以前的任何值。")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220317224143281.png",alt:"image-20220317224143281"}})]),t._v(" "),a("ul",[a("li",[a("p",[t._v("单调写一致性")]),t._v(" "),a("p",[t._v("系统保证对同一个进程的写操作串行化。")])])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220317224245157.png",alt:"image-20220317224245157"}})]),t._v(" "),a("h4",{attrs:{id:"一致性模型图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一致性模型图"}},[t._v("#")]),t._v(" 一致性模型图")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220317224446843.png",alt:"image-20220317224446843"}})])])}),[],!1,null,null,null);a.default=s.exports}}]);