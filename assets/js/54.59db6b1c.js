(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{411:function(n,e,a){"use strict";a.r(e);var t=a(8),r=Object(t.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("p",[n._v("本文介绍了Netty的核心API以及他们的使用。")]),n._v(" "),e("h3",{attrs:{id:"netty核心api介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#netty核心api介绍"}},[n._v("#")]),n._v(" Netty核心API介绍")]),n._v(" "),e("h4",{attrs:{id:"channelhandler及其实现类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channelhandler及其实现类"}},[n._v("#")]),n._v(" ChannelHandler及其实现类")]),n._v(" "),e("p",[n._v("API关系如下：")]),n._v(" "),e("div",{staticClass:"language-mermaid line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-mermaid"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("classDiagram")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("direction")]),n._v(" BT\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("class")]),n._v(" ChannelHandler "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token annotation important"}},[n._v("<<Interface>>")]),n._v("\n\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("class")]),n._v(" ChannelHandlerAdapter\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("class")]),n._v(" ChannelInboundHandler "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token annotation important"}},[n._v("<<Interface>>")]),n._v("\n\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("class")]),n._v(" ChannelInboundHandlerAdapter\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("class")]),n._v(" ChannelOutboundHandler "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("{")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token annotation important"}},[n._v("<<Interface>>")]),n._v("\n\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[n._v("}")]),n._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[n._v("class")]),n._v(" ChannelOutboundHandlerAdapter\n\n\nChannelInboundHandler  "),e("span",{pre:!0,attrs:{class:"token arrow operator"}},[n._v("--\x3e")]),n._v("  ChannelHandler \nChannelInboundHandlerAdapter  "),e("span",{pre:!0,attrs:{class:"token arrow operator"}},[n._v("--\x3e")]),n._v("  ChannelHandlerAdapter \nChannelInboundHandlerAdapter  "),e("span",{pre:!0,attrs:{class:"token arrow operator"}},[n._v("..>")]),n._v("  ChannelInboundHandler \nChannelHandlerAdapter  "),e("span",{pre:!0,attrs:{class:"token arrow operator"}},[n._v("..>")]),n._v("  ChannelHandler \nChannelOutboundHandler  "),e("span",{pre:!0,attrs:{class:"token arrow operator"}},[n._v("--\x3e")]),n._v("  ChannelHandler \nChannelOutboundHandlerAdapter  "),e("span",{pre:!0,attrs:{class:"token arrow operator"}},[n._v("--\x3e")]),n._v("  ChannelHandlerAdapter \nChannelOutboundHandlerAdapter  "),e("span",{pre:!0,attrs:{class:"token arrow operator"}},[n._v("..>")]),n._v("  ChannelOutboundHandler \n")])]),n._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[n._v("1")]),e("br"),e("span",{staticClass:"line-number"},[n._v("2")]),e("br"),e("span",{staticClass:"line-number"},[n._v("3")]),e("br"),e("span",{staticClass:"line-number"},[n._v("4")]),e("br"),e("span",{staticClass:"line-number"},[n._v("5")]),e("br"),e("span",{staticClass:"line-number"},[n._v("6")]),e("br"),e("span",{staticClass:"line-number"},[n._v("7")]),e("br"),e("span",{staticClass:"line-number"},[n._v("8")]),e("br"),e("span",{staticClass:"line-number"},[n._v("9")]),e("br"),e("span",{staticClass:"line-number"},[n._v("10")]),e("br"),e("span",{staticClass:"line-number"},[n._v("11")]),e("br"),e("span",{staticClass:"line-number"},[n._v("12")]),e("br"),e("span",{staticClass:"line-number"},[n._v("13")]),e("br"),e("span",{staticClass:"line-number"},[n._v("14")]),e("br"),e("span",{staticClass:"line-number"},[n._v("15")]),e("br"),e("span",{staticClass:"line-number"},[n._v("16")]),e("br"),e("span",{staticClass:"line-number"},[n._v("17")]),e("br"),e("span",{staticClass:"line-number"},[n._v("18")]),e("br"),e("span",{staticClass:"line-number"},[n._v("19")]),e("br"),e("span",{staticClass:"line-number"},[n._v("20")]),e("br"),e("span",{staticClass:"line-number"},[n._v("21")]),e("br"),e("span",{staticClass:"line-number"},[n._v("22")]),e("br"),e("span",{staticClass:"line-number"},[n._v("23")]),e("br"),e("span",{staticClass:"line-number"},[n._v("24")]),e("br"),e("span",{staticClass:"line-number"},[n._v("25")]),e("br"),e("span",{staticClass:"line-number"},[n._v("26")]),e("br")])]),e("blockquote",[e("p",[n._v("如果图片无法显示，请看这里")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220420001840283.png",alt:"image-20220420001840283"}})])]),n._v(" "),e("p",[n._v("Netty开发中需要定义一个Handler类去实现ChannelHandler接口或其子类或其实现类，然后通过重写相关方法实现业务逻辑：")]),n._v(" "),e("ul",[e("li",[n._v("public void channelActive(ChannelHandlerContext ctx)：通道就绪事件")]),n._v(" "),e("li",[n._v("public void read(ChannelHandlerContext ctx, Object msg)：通道读取数据事件")]),n._v(" "),e("li",[n._v("public void readComplete(ChannelHandlerContext ctx)：数据读取完毕事件")]),n._v(" "),e("li",[n._v("publi void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)：通道发生异常事件")])]),n._v(" "),e("h4",{attrs:{id:"channelpipline"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channelpipline"}},[n._v("#")]),n._v(" ChannelPipline")]),n._v(" "),e("p",[n._v("ChannelPipline是一个handler集合，它负责处理和拦截inbound和outbound事件和操作，相当于一个贯穿Netty的责任链。")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220420120120457.png",alt:"image-20220420120120457"}})]),n._v(" "),e("p",[n._v("如果客户端和服务端的handler是一样的，那么消息从客户端到服务端或者反过来，每个inbound类型或许outbound类型只会经过一次，混合类型（同时实现了inbound和outbound的handler）的handler会经过两次。")]),n._v(" "),e("p",[n._v("ChannelPipline中的每个ChannelHandlerContext中都含有一个ChannelHandler。")]),n._v(" "),e("p",[e("strong",[n._v("InboundHandler是按照Pipline的加载顺序顺序执行，OutboundHandler是按照Pipline的加载顺序逆序执行。")])]),n._v(" "),e("h4",{attrs:{id:"channelhandlercontext"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channelhandlercontext"}},[n._v("#")]),n._v(" ChannelHandlerContext")]),n._v(" "),e("p",[n._v("事件处理器上下文对象，Pipline链中的实际处理节点。")]),n._v(" "),e("p",[n._v("每个处理节点ChannelhandlerContxet包含一个具体的处理器ChannelHandler，同时ChannelHandlerContext中也绑定了对应的ChannelPipline和Channel的信息，方便对ChannelHandler进行调用。常用方法如下：")]),n._v(" "),e("ul",[e("li",[n._v("ChannelFuture close()：关闭通道")]),n._v(" "),e("li",[n._v("ChannelOutboundInvoker flush()：刷新")]),n._v(" "),e("li",[n._v("ChannelFuture writeAndFlush(Object msg)：将数据写入ChannelPipline中当前ChannelHandler的下一个ChannelHandler开始处理（出站）")])]),n._v(" "),e("h4",{attrs:{id:"channeloption"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channeloption"}},[n._v("#")]),n._v(" ChannelOption")]),n._v(" "),e("p",[n._v("Netty在创建Channel实例后，一般都需要设置ChannelOption参数。")]),n._v(" "),e("p",[n._v("ChannelOption是socket的标准参数，不是Netty特有的。常见的参数如下：")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("ChannelOption.SO_BACKLOG：对应TCP/IP协议listen函数中的backlog参数，用来初始化服务器可连接队列大小。")]),n._v(" "),e("p",[n._v("服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。")]),n._v(" "),e("p",[n._v("多个客户端来的时候，服务端将不能处理的客户端请求放在等待队列里，backlog参数指定了队列的大小。")])]),n._v(" "),e("li",[e("p",[n._v("ChannelOption.SO_KEEPALIVE：一直保存连接处于活动状态。该参数用于设置TCP连接。")]),n._v(" "),e("p",[n._v("当设置该选项之后，会测试连接的状态，用于可能长时间没有数据交流的连接。")]),n._v(" "),e("p",[n._v("当设置该选项后，如果两小时内没有数据通信时，TCP会自动发送一个活动探测数据报文。")])])]),n._v(" "),e("h4",{attrs:{id:"channelfuture"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#channelfuture"}},[n._v("#")]),n._v(" ChannelFuture")]),n._v(" "),e("p",[n._v("表示Channel中异步I/O操作的结果。")]),n._v(" "),e("p",[n._v("在Netty中所有的I/O操作都是异步的，IO的调用会直接返回，调用者并不能立即获得结果，但是可以通过ChannelFuture来获取I/O操作的处理状态。")]),n._v(" "),e("p",[n._v("常用方法如下：")]),n._v(" "),e("ul",[e("li",[n._v("Channel channel()：返回当前正在进行IO操作的通道")]),n._v(" "),e("li",[n._v("ChannelFuture sync()：等待异步操作执行完毕，将异步改为同步")])]),n._v(" "),e("h4",{attrs:{id:"eventloopgroup和实现类nioeventloopgroup"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#eventloopgroup和实现类nioeventloopgroup"}},[n._v("#")]),n._v(" EventLoopGroup和实现类NioEventLoopGroup")]),n._v(" "),e("p",[n._v("EventLoopGroup是一组EventLoop的抽象，Netty为了更好的利用多核CPU的资源，一般会有多个EventLoop同时同工作，每个EventLoop维护着一个Selector对象。")]),n._v(" "),e("p",[n._v("EventLoopGroup提供next接口，可以从组里面按照一定规则，获取其中一个EventLoop来处理任务。")]),n._v(" "),e("p",[n._v("在Netty的服务端编程中，一般需要提供两个EventLoopGroup，例如：BossEventLoopGroup和WorkerEventLoopGroup。")]),n._v(" "),e("p",[n._v("通常一个服务端口就是一个ServerSocketChannel，对应一个Selector和一个EventLoop线程。")]),n._v(" "),e("p",[n._v("BossEventLoop负责接收客户端连接，并将SocketChannel交给WorkerEventLoopGroup进行I/O处理。")]),n._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/terwer/upload/img/image-20220420180506604.png",alt:"image-20220420180506604"}})]),n._v(" "),e("p",[n._v("BossEventLoopGroup通常是一个单线程的EventLoop，EventLoop维护者一个注册了ServerSocketChannel的Selector实例。")]),n._v(" "),e("p",[n._v("BossEventLoop不断轮询Selector，将连接事件分离出来，通常是ON_ACCEPT事件，然后将接收到的SocketChannel交给WorkerEventLoopGroup。")]),n._v(" "),e("p",[n._v("WorkerEventLoopGroup会由next选择其中一个EventLoopGroup来讲这个SocketChannel注册到其维护的Selector，并对其后的IO事件进行处理。")]),n._v(" "),e("p",[n._v("一般情况下都是使用NioEventLoopGroup，常用方法如下：")]),n._v(" "),e("ul",[e("li",[n._v("public NioEventLoopGroup()：构造方法，创建线程组")]),n._v(" "),e("li",[n._v("public Future<?> shutdownGracefully()：断开连接，关闭线程")])]),n._v(" "),e("h4",{attrs:{id:"serverbootstrap和bootstrap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#serverbootstrap和bootstrap"}},[n._v("#")]),n._v(" ServerBootStrap和Bootstrap")]),n._v(" "),e("p",[n._v("ServerBootstrap是Netty中的服务端启动助手，通过它可以完成服务端的各种配置。")]),n._v(" "),e("p",[n._v("Bootstrap是Netty中的客户端启动助手，通过它可以完成客户端的各种配置。常见方法如下：")]),n._v(" "),e("ul",[e("li",[n._v("public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)：用于服务端，用于设置两个EventLoop")]),n._v(" "),e("li",[n._v("public B group(EventLoopGroup group)：用于客户端，用于设置一个EventLoop")]),n._v(" "),e("li",[n._v("public B channel(Class<? Extends C> channelClass)：该方法用于设置服务端的通道实现")]),n._v(" "),e("li",[n._v("public B option(ChannelOption option, T value)：用来给ServerChannel添加配置")]),n._v(" "),e("li",[n._v("public ServerBootstrap childOption(ChannelOption option, T value)：用来给接收到的通道添加配置")]),n._v(" "),e("li",[n._v("public ServerBootstrap childHandler(ChannelHandler childHandler)：该方法设置业务处理类，自定义Handler")]),n._v(" "),e("li",[n._v("public ChannelFuture bind(int inetPort)：该方法用于服务端，用来设置占用的端口号")]),n._v(" "),e("li",[n._v("public ChannelFuture connect(String inetPort, int inetPort)：该方法用于客户端，用于连接服务端")])]),n._v(" "),e("h4",{attrs:{id:"unpooled类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#unpooled类"}},[n._v("#")]),n._v(" Unpooled类")]),n._v(" "),e("p",[n._v("这是Netty提供的一个专门用来操作缓冲区的工具类，常用方法如下：")]),n._v(" "),e("ul",[e("li",[n._v("public static ByteBuf copiedBuffer(CharSequence string, Charset charset)：通过给定的数据和字符编码返回一个BuyeBuf对象，类似于NIO中的ByteBuffer对象。")])])])}),[],!1,null,null,null);e.default=r.exports}}]);