(window.webpackJsonp=window.webpackJsonp||[]).push([[214],{569:function(v,t,_){"use strict";_.r(t);var a=_(8),e=Object(a.a)({},(function(){var v=this,t=v._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"java-se-lesson-3-单例模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#java-se-lesson-3-单例模式"}},[v._v("#")]),v._v(" Java SE Lesson 3：单例模式")]),v._v(" "),t("ol",[t("li",[v._v("接口中声明的方法都是抽象方法，抽象方法都是 "),t("code",[v._v("public")]),v._v(" 的。")]),v._v(" "),t("li",[v._v("接口中也可以定义成员变量，"),t("strong",[v._v("接口中的成员变量都是 "),t("code",[v._v("public")]),v._v("、"),t("code",[v._v("static")]),v._v("、"),t("code",[v._v("final")]),v._v("的")]),v._v("。")]),v._v(" "),t("li",[v._v("一个类不能既是 "),t("code",[v._v("final")]),v._v(" ，又是 "),t("code",[v._v("abstract")]),v._v(" 的，因为 "),t("code",[v._v("abstract")]),v._v(" 是定义一个方法上的约定，让子类去实现这种约定，而 "),t("code",[v._v("final")]),v._v(" 明确说明该类不能被继承，两者矛盾。因此，一个类不能既是 "),t("code",[v._v("final")]),v._v(" ，又是 "),t("code",[v._v("abstract")]),v._v(" 的。")]),v._v(" "),t("li",[t("code",[v._v("Desgin Pattern")]),v._v("（设计模式）。单例模式（Singleton），表示一个类始终只会生成唯一的一个对象。")]),v._v(" "),t("li")]),v._v(" "),t("h1",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),t("p",[v._v("《图解设计模式》")])])}),[],!1,null,null,null);t.default=e.exports}}]);