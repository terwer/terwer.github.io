---
title: Java面试FAQ1-50
date: '2023-09-14 17:47:48'
meta:
  - name: keywords
    content: 分布式锁 悲观锁 乐观锁 并发问题 Java内存模型
  - name: description
    content: >-
      本文介绍了使用分布式锁解决并发问题的一般思路，包括数据库锁和悲观锁的使用，以及它们可能导致的锁表和线程阻塞问题。同时，文章提到了并发的三个核心问题，包括缓存一致性、处理器优化和指令重排。最后，文章简要介绍了Java内存模型（JMM）的概念和目的，以解决多线程共享内存时可能出现的数据不一致性问题。
tags:
  - 分布式锁
  - 悲观锁
  - 乐观锁
  - 并发问题
  - Java内存模型
categories:
  - 求职面试
  - 面试题
permalink: /post/java-interview-faq150-1ujbr4.html
author:
  name: terwer
  link: http://localhost:8002/terwer
---
本文介绍了使用分布式锁解决并发问题的一般思路，包括数据库锁和悲观锁的使用，以及它们可能导致的锁表和线程阻塞问题。同时，文章提到了并发的三个核心问题，包括缓存一致性、处理器优化和指令重排。最后，文章简要介绍了Java内存模型（JMM）的概念和目的，以解决多线程共享内存时可能出现的数据不一致性问题。

<!-- more -->




1. 怎么使用分布式锁解决并发问题？

   * 一般思路是引入第三方系统，进行互斥性协调。
   * 实现方案一般有 3 个

     * 数据库

       在数据库建一张表，加锁插入记录，解锁删除记录。通过数据库的唯一性约束来避免。

       数据库的悲观锁也可以，但是会造成锁表和线程阻塞。
     * Zookeeper
     * Redis

‍

2. 数据库的悲观锁为什么会造成锁表和线程阻塞？

   * 锁表：悲观锁在读取或修改数据时，会预先认为其他事务可能会干扰它，因此会尝试获取锁来保护数据。如果多个事务同时尝试获取相同数据的锁，其中一个事务会成功，而其他事务将被阻塞，直到锁被释放。这种情况下，如果大量事务同时争夺相同数据的锁，就可能导致整个数据表被锁住，进而影响了数据库的性能。
   * 线程阻塞：当一个事务获取了悲观锁并且正在使用数据时，其他事务如果需要访问相同数据，则会被阻塞等待锁的释放。这导致了线程阻塞，降低了数据库的并发性能，因为其他事务必须等待锁的释放才能继续执行。如果锁的持有时间很长或锁的争夺非常激烈，线程阻塞会显著影响数据库的吞吐能力。
   * 要减轻这些问题，可以考虑使用乐观锁或其他并发控制机制，以减少锁表和线程阻塞的潜在风险。乐观锁不会阻塞其他事务，而是在提交时检查数据是否被修改，从而减少了锁的使用和线程阻塞的可能性。

‍

3. 并发的三个核心问题是什么？

   * 背景

     在 CPU 和主存之间增加缓存，在多线程场景下会存在**缓存一致性问题**。

     除了这种情况，还有一种硬件问题也比较重要。那就是为了使处理器内部的运算单元能够尽量的被充分利用，处理器可能会对输入代码进行乱序执行处理。这就是**处理器优化**。

     除了现在很多流行的处理器会对代码进行优化乱序处理，很多编程语言的编译器也会有类似的优化，比如 Java 虚拟机的即时编译器（JIT）也会做**指令重排**。
   * 概念对应关系

     * **缓存一致性问题**其实就是**可见性问题**。
     * **处理器优化**可以导致**原子性问题**的。
     * **指令重排**会导致**有序性问题**。
   * 参考

     [https://mp.weixin.qq.com/s/r_gtAdTVBKSm52To-2d4Ew](https://mp.weixin.qq.com/s/r_gtAdTVBKSm52To-2d4Ew)

‍

4. 什么是 Java 内存模型？

   * Java 内存模型，一般指的是 JDK 5 开始使用的新的内存模型，主要由 JSR-133: JavaTM Memory Model and Thread Specification 描述。可以参看下这份 PDF 文档（[http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf](http://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf)）
   * ​![JMM](https://img1.terwer.space/api/public/202309142209481.png "Java内存模型")​
   * **JMM 是一种规范，目的是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。**
