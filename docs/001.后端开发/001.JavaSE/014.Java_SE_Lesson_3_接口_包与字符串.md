---
title: Java_SE_Lesson_3：接口、单例模式、包与字符串
date: 2022-09-30 20:42:53
permalink: /post/ava-se-lesson-3-interface_package-and-string.html
meta:
  - name: keywords
    content: 接口 方法 成员 变量 声明
  - name: description
    content: >-
      接口中所声明的方法都是抽象方法。接口中的方法都是public​的。接口中也可以定义成员变量。接口中的成员变量都是publicfinalstatic的。一个类不能既是final又是abstract的。因为abstract的主要目的是啥定义一种约定让子类去实现这种约定而final表示该类不能被继承。这样abstract希望该类可以被继承而final明确说明该类不能被继承两者矛盾。因此一个类不能既是final的又是abstract的。desginpattern（设计模式）。单例模式（singleton）publ
categories:
  - 默认分类
tags:
  - 接口
  - 方法
  - 成员
  - 变量
  - 声明
author:
  name: terwer
  link: https://github.com/terwer
---


1. 接口中所声明的方法都是抽象方法。接口中的方法都是 `public`​ 的。
2. 接口中也可以定义成员变量。接口中的成员变量都是 `public` ， `final` ， `static` 的。
3. 一个类不能既是 final 又是 abstract 的。因为 abstract 的主要目的是啥定义一种约定，让子类去实现这种约定，而 final 表示该类不能被继承。

   这样 abstract 希望该类可以被继承而 final 明确说明该类不能被继承，两者矛盾。

   因此一个类不能既是 final 的又是 abstract 的。

4. Desgin Pattern（设计模式）。

   单例模式（Singleton）

   ```java
   public class SingletonTest {
       public static void main(String[] args) {
           Singleton s1 = Singleton.getInstance();
           Singleton s2 = Singleton.getInstance();

           System.out.println(s1 == s2);
       }
   }

   class Singleton {
       private static Singleton singleton = new Singleton();

       private Singleton() {
       }

       public static Singleton getInstance() {
           return singleton;
       }
   }
   ```

或者

```java
public class SingletonTest {
    public static void main(String[] args) {
        Singleton s1 = Singleton.getInstance();
        Singleton s2 = Singleton.getInstance();

        System.out.println(s1 == s2);
    }
}

class Singleton {
    private static Singleton singleton;

    private Singleton() {
    }

    public static Singleton getInstance() {
        if (null == singleton) {
            singleton = new Singleton();
        }
        return singleton;
    }
}
```

注意：方式二，在多线程的时候，可能会出现线程不安全，不是单例的情况。

> 文章更新历史
>
> 2022-10-10 feat:初稿。
