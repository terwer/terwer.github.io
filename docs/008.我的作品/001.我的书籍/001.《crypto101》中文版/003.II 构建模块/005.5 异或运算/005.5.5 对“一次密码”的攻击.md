---
title: 5 对“一次密码”的攻击
date: '2023-11-18 20:09:45'
meta: []
categories:
  - 我的作品
  - 我的书籍
  - 《crypto101》中文版
  - II 构建模块
  - 5 异或运算
permalink: /post/55-attack-on-one-password-z1bmwvq.html
author:
  name: terwer
  link: https://github.com/terwer
---


<!-- more -->




# 5.5 对“一次密码”的攻击

一次性密码的安全性保证只有在正确使用时才成立。<span style="font-weight: bold;" data-type="strong">首先，一次性密码必须由真正随机的数据组成。其次，一次性密码只能使用一次（因此得名）</span>  。不幸的是，大多数声称是“一次性密码”的商业产品都是毫无用处的 [^1]，它们至少不满足这两个属性中的一个。

## 未使用真正随机的数据

首要问题在于，他们使用各种确定性结构来生成一次性密码本，而不是使用真正随机的数据。这并不一定是不安全的：事实上，最明显的例子，同步流密码，是我们在本书后面将要看到的内容。然而，这确实使一次性密码本失去了“不可破解”的安全性质。最好为最终用户提供一个更诚实的密码系统，而不是一个关于其安全性质撒谎的系统。

## 再次使用“一次性”密码

另一个问题是密钥的重复使用，这更为严重。假设攻击者获取了两个使用相同“一次性”密码加密的密文。攻击者可以对这两个密文进行异或操作，这也等同于对明文进行异或操作：

$$
\begin{align*}
c_1\oplus c_2 &=(p_1\oplus k)\oplus(p_2\oplus k)\\
&=p_1\oplus k\oplus p_2\oplus k\\
&=p_1\oplus p_2\oplus k\oplus k\\
&=p_1\oplus p_2\oplus0\\
&=p_1\oplus p_2\\
\end{align*}
$$

异或运算的性质：

$$
\begin{align*}
(a\oplus b &=b\oplus a)\\
(x\oplus x &=0)\\
(x\oplus0 &=x)
\end{align*}
$$

乍一看，这可能看起来不像一个问题。要提取 $p1$ 或 $p2$ ，您需要取消 XOR 操作，这意味着您需要知道另一个明文。问题是，即使在两个明文上进行 XOR 操作的结果，也包含有关明文本身的相当多信息。我们将使用一些来自破损的“一次性”加密的图像来直观地说明这一点，从 Figure 5.1 开始。

<span style="font-weight: bold;" data-type="strong">密码拖拽</span>

破解多次密码系统的经典方法包括“crib-dragging”，这是一个使用小序列的过程，这些小序列有很高的概率出现。这些序列被称为“cribs”。crib-dragging 这个名称来源于这样一个事实，即这些小的“cribs”从左到右拖动穿过每个密文，并且从上到下穿过密文，希望在某个地方找到匹配。这些匹配形成了进一步解密的起始点或“crib”的位置。

这个想法相当简单。假设我们有用相同的“一次性”密钥 $K$ [^2] 、加密的若干加密消息 $C_i$ 。如果我们能够正确猜测出图 5.1 中其中一个明文，即重复使用的密钥，它们各自的密文以及密文的异或运算结果。当我们对密文进行异或运算时，明文的相关信息显然会泄漏出来。

​![](https://img1.terwer.space/api/public/202311181907514.jpg)​

图 5.1

消息，假设为 $C_j$ ，我们已经知道 $K$：

$$
\begin{align*}
C_j ⊕ P_j &= (P_j ⊕ K) ⊕ P_j \\
         &= K ⊕ P_j ⊕ P_j \\
         &= K ⊕ 0 \\
         &= K
\end{align*}
$$

由于 $K$ 是共享的密钥，现在我们可以使用它来解密所有其他消息，就像我们是接收方一样：

$$
P_i = C_i ⊕ K
$$

对于所有的 $i$ 由于通常无法猜测整个消息，这实际上是行不通的。但是，我们可能能够猜测消息的部分。

猜测明文的部分比猜测整个明文容易得多。假设我们知道明文是英文。有一些我们知道的非常常见的序列，例如（符号 `␣` 表示空格）：

• `␣the␣` 和变体，如 `.␣The␣`

• `␣of␣` 和变体

• `␣to␣` 和变体

• `␣and␣`（无变体；仅出现在句子中间）

• `␣a␣` 和变体

如果我们对明文了解更多，我们可以做出更好的猜测。例如，如果是 HTTP 服务的 HTML，我们期望看到诸如 `Content-Type`、`<a>` 等内容。这仅告诉我们哪些明文序列可能性更大，给了我们可能的猜测。

我们如何知道这些猜测中有哪些是正确的呢？如果我们的猜测是正确的，我们也会知道在那个位置上的所有其他明文，使用之前描述的技术。我们可以简单地查看这些明文，并决定它们是否正确。

实际上，这个过程需要自动化，因为可能的猜测太多了。幸运的是，这是相当容易做到的。例如，一个非常简单但有效的方法是统计在猜测的明文中不同符号出现的频率：如果消息包含英文文本，我们期望看到很多字母 e、t、a、o、i、n。如果我们看到的是二进制的无意义内容，我们就知道这个猜测可能是不正确的，或者那个消息实际上是二进制数据。

这些小而高概率的序列被称为“cribs”，因为它们是更大解密过程的开端。假设你的 crib，`the`，成功地在另一条消息中找到了五个字母的序列 `t thr` 。然后你可以使用字典查找以 `thr` 开头的常见单词，比如 `through` 。如果那个猜测是正确的，它将在所有密文中揭示出另外四个字节，这些字节可以用来揭示更多内容。类似地，你可以使用字典找到以 `t` 结尾的单词。

对于我们更多了解的一些明文，这变得更加有效。如果某些 HTTP 数据中包含了明文 `ent-Len`，那么我们可以将其扩展为 `Content-Length:`，揭示更多的字节。

虽然这种技术在两条消息使用相同密钥加密时就可以起效，但很明显，如果使用相同密钥的密文更多，这个过程会变得更加容易，因为所有步骤都变得更加有效：

- 我们会获得更多的 cribbing 位置。

每次成功使用 crib（线索）和猜测时，会揭示更多纯文本字节，从而在其他位置提供更多猜测选项。

- 对于任何给定位置，可用的密文更多，使得猜测验证变得更容易，有时更准确。这些只是破解多次密码的简单思路。尽管它们已经相当有效，但人们通过应用基于自然语言分析的先进统计模型发明了更有效的方法。这进一步证明了多次密码有多么脆弱。

  > [MWES06] Joshua Mason, Kathryn Watkins, Jason Eis- ner, and Adam Stubblefield. A natural lan- guage approach to automated cryptanalysis of two-time pads. In Proceedings of the 13th ACM conference on Computer and Communica- tions Security, CCS ʻ06, 235–244. New York, NY, USA, 2006. ACM. URL: http://www.cs.jhu. edu/~jason/papers/mason+al.ccs06.pdf, doi:10.1145/1180405.1180435.
  >

[^1]: 这是用来指称各种声称拥有非凡益处和特性，却实际上未能实现任何其中的产品的术语。

[^2]: 我们在提及整个消息时使用大写字母，而不仅仅是消息的部分。

‍
