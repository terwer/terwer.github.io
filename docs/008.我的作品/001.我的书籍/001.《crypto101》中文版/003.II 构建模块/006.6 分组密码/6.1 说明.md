---
title: ' 说明'
date: '2023-11-18 12:17:36'
meta: []
categories:
  - 我的作品
  - 我的书籍
  - 《crypto101》中文版
  - II 构建模块
  - 6 分组密码
permalink: /post/1-description-z274c9l.html
author:
  name: terwer
  link: https://github.com/terwer
---


<!-- more -->




块密码是一种算法，它加密固定长度的数据块。

加密函数 $E$ 通过使用私密密钥 $k$ 将明文块 $P$ 转换为密文块 $C$：

$$
C = E(k, P)
$$

明文和密文块都是位序列，并且始终具有相同的大小。块密码的块大小是固定的。密钥空间是所有可能密钥的集合。一旦我们将明文块加密为密文块，它们随后可以解密以恢复原始的明文块。

原始明文块 $P$ 是使用解密函数 $D$ 生成的。该函数接受密文块 $C$ 和密钥 $k$（与加密块时使用的相同密钥）作为输入。

$$
P = D(k, C)
$$

或者，在块中进行可视化表示：

​![Screenshot_2023-11-18-12-26-01-52_c37d74246d9c81aa0bb824b57eaf7062](https://img1.terwer.space/api/public/202311182134722.jpg)​

一个 <span style="font-weight: bold;" data-type="strong">分组密码</span> 是 <span style="font-weight: bold;" data-type="strong">对称密钥加密</span> 方案的示例，也被称为 <span style="font-weight: bold;" data-type="strong">密钥加密</span> 方案。<span style="font-weight: bold;" data-type="strong">相同的密钥用于加密和解密</span> 。稍后在本书中，我们将其与具有不同加密和解密密钥的公钥加密算法进行对比。

分组密码是一种键控置换。它是一种置换，因为分组密码将每个可能的分组映射到另一个分组。它也是一种键控置换，因为密钥确定了哪些分组映射到哪些分组。分组密码是的置换是非常重要的，因为接收者必须将分组映射回原始分组。

我们通过查看一个拥有不切实际的、小的 4 位分组大小的分组密码来说明这一点。$2^4 = 16$ 个可能的分组。由于每个分组映射到一个十六进制数字，我们用该数字表示分组。

选定秘密密钥后，块密码使用它来确定任何给定块的加密。我们用一支箭来阐述这种关系。箭头的尾部是使用密钥 k 下块的 E 加密，箭头的箭头部分映射到该块。

在图 6.2 中，请注意排列并非仅由一个庞大的循环组成。它包含一个包含 7 个元素的大循环，以及若干包含 4、3 和 2 个元素的较小循环。同样完全有可能一个元素加密为自身。这在选择随机排列时是可以预期的，这大致是块密码所做的。

​![Screenshot_2023-11-18-12-35-53-39_c37d74246d9c81aa0bb824b57eaf7062](https://img1.terwer.space/api/public/202311182135105.jpg)

图 6.2：在特定密钥 k 下由块密码创建的加密置换。​

当你解密而非加密时，块密码计算逆排列。在图 6.3 中，我们得到相同的插图。插图之间的区别在于所有箭头指向相反的方向。

​![image](https://img1.terwer.space/api/public/202311182152156.png)​

这里关键定义了哪些块映射到哪些块。不同的关键将导致不同的箭头集，正如您在图 6.4 中所见。

在这个插图中，你甚至会注意到存在两个长度为 1 的排列：一个元素映射到自身。这同样是在选择随机排列时可以预期的情况。

对于给定的密钥，知道一堆（输入，输出）对不应该给你关于该密钥下的任何其他（输入，输出）对的信息。只要我们谈论的是一个假设完美的块密码，除了“穷举”密钥（即尝试每一个密钥，直到找到正确的密钥），没有比这更容易解密一个块的方式了。

​![image](https://img1.terwer.space/api/public/202311182152889.png)​

图 6.3：由相同密钥 k 下的块密码产生的解密排列。它是加密排列的反向，即所有箭头都反转。

‍

我们的玩具示例分组密码仅具有 4 位分组，即 2 的 4 次方等于 16 种可能性。而真实的现代分组密码具有更大的分组大小，例如 128 位，即 2 的 128 次方（略大于 10 的 38.5 次方）个可能的分组。数学告诉我们，对于一个包含 n 个元素的集合，存在 $n!$（读作“n 的阶乘”）不同的排列方式。它被定义为从 1 到 n 的所有数字的乘积：

$$
n!=1\cdot2\cdot3\cdot...\cdot(n−1)\cdot n
$$

阶乘增长速度极快。例如，$5! = 120$，$10! = 3628800$，这种增长趋势还在继续。对于具有 128 位块大小的密码的块集合的排列数量是 $(2^{128})!$。

仅仅 $2^{128}$ 就已经非常巨大（需要 39 位数字来表示它），所以 $(2^{128})!$ 是一个难以理解的巨大数字。常见的密钥大小仅在 128 到 256 位范围内，因此密码可以执行的排列数量只有介于 $2^{128}$ 到 $2^{256}$ 之间。这只是所有可能的排列的一小部分，但没关系：这一小部分仍然远远不够小，以至于攻击者可以轻易尝试所有排列。

​![image](https://img1.terwer.space/api/public/202311182152192.png)​

图 6.4：由块密码在不同密钥下产生的加密排列。

当然，块密码应该尽可能易于计算，只要它不会牺牲上述的任何特性。
